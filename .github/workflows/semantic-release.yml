name: Automated Semantic Versioning and Release

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  NODE_VERSION: '18'
  PYTHON_VERSION: '3.13'

jobs:
  test-frontend:
    name: Test Frontend
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./frontend
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm run test:coverage

      - name: Run linting
        run: npm run lint

      - name: Build application
        run: npm run build

  test-backend:
    name: Test Backend
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./backend
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install uv
        uses: astral-sh/setup-uv@v2
        with:
          version: "latest"

      - name: Install dependencies
        run: |
          uv sync

      - name: Run tests
        env:
          DATABASE_URL: postgres://postgres:postgres@localhost:5432/test_db
          DJANGO_SETTINGS_MODULE: customer_management.test_settings
        run: |
          uv run python -m django migrate --settings=customer_management.test_settings
          uv run pytest --cov=. --cov-report=xml --cov-report=term

      - name: Run linting
        run: |
          uv run black --check .
          uv run isort --check-only .
          uv run flake8 .

  semantic-release:
    name: Semantic Release
    runs-on: ubuntu-latest
    needs: [test-frontend, test-backend]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    permissions:
      contents: write
      issues: write
      pull-requests: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install frontend dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Install backend dependencies
        working-directory: ./backend
        run: |
          python -m pip install --upgrade pip
          pip install -e .[dev]

      - name: Get next version
        id: get_version
        working-directory: ./frontend
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Run semantic-release in dry-run mode to get next version
          npx semantic-release --dry-run > release_output.txt 2>&1 || true
          
          # Extract version from output
          NEXT_VERSION=$(grep "The next release version is" release_output.txt | sed 's/.*The next release version is \(.*\)/\1/' || echo "")
          
          if [ -z "$NEXT_VERSION" ]; then
            echo "No release needed"
            echo "should_release=false" >> $GITHUB_OUTPUT
          else
            echo "Next version: $NEXT_VERSION"
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "next_version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          fi

      - name: Update backend version
        if: steps.get_version.outputs.should_release == 'true'
        working-directory: ./backend
        run: |
          # Create a temporary tag for setuptools-scm
          git tag "v${{ steps.get_version.outputs.next_version }}"
          
          # Generate version file using our script
          python ../scripts/generate_version.py
          
          # Remove temporary tag
          git tag -d "v${{ steps.get_version.outputs.next_version }}"

      - name: Run semantic release
        if: steps.get_version.outputs.should_release == 'true'
        working-directory: ./frontend
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: npx semantic-release

      - name: Create backend release assets
        if: steps.get_version.outputs.should_release == 'true'
        working-directory: ./backend
        run: |
          # Build Python package
          python -m pip install build
          python -m build
          
          # Create release notes for backend
          cat > backend_release_notes.md << EOF
          # Backend Release v${{ steps.get_version.outputs.next_version }}
          
          This release includes the Django backend updates for version ${{ steps.get_version.outputs.next_version }}.
          EOF

      - name: Update git tags for backend
        if: steps.get_version.outputs.should_release == 'true'
        run: |
          # Create backend-specific tag
          git tag "backend-v${{ steps.get_version.outputs.next_version }}"
          git push origin "backend-v${{ steps.get_version.outputs.next_version }}"

  version-sync:
    name: Sync Version Across Components  
    runs-on: ubuntu-latest
    needs: semantic-release
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Get latest release version
        id: get_latest
        run: |
          LATEST_VERSION=$(git describe --tags --abbrev=0 2>/dev/null | sed 's/^v//' || echo "0.1.0")
          echo "latest_version=$LATEST_VERSION" >> $GITHUB_OUTPUT
          echo "Latest version: $LATEST_VERSION"

      - name: Update docker-compose version
        run: |
          # Update version in docker-compose.yml if it exists
          if [ -f "docker-compose.yml" ]; then
            sed -i "s/image: customer-management-frontend:.*/image: customer-management-frontend:${{ steps.get_latest.outputs.latest_version }}/" docker-compose.yml
            sed -i "s/image: customer-management-backend:.*/image: customer-management-backend:${{ steps.get_latest.outputs.latest_version }}/" docker-compose.yml
          fi

      - name: Update documentation
        run: |
          # Update version in README if needed
          if [ -f "README.md" ]; then
            sed -i "s/Version: [0-9]\+\.[0-9]\+\.[0-9]\+/Version: ${{ steps.get_latest.outputs.latest_version }}/" README.md
          fi

      - name: Commit version sync changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          if [ -n "$(git status --porcelain)" ]; then
            git add .
            git commit -m "chore: sync version ${{ steps.get_latest.outputs.latest_version }} across components [skip ci]"
            git push
          else
            echo "No changes to commit"
          fi